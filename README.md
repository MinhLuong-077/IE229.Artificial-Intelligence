# IE229.Artificial-Intelligence
## CIFAR10 
1. 問題の説明
* 入力は10層の32x32カラー画像です 
* 出力は、10クラスのうち1クラスに属する画像です。
2. データセットの簡単な説明
* CIFAR-10データセットは、10クラスの60000の32x32カラー画像で構成され、クラスごとに6000の画像があります。 50000のトレーニング画像と10000のテスト画像があります。 データセットは、5つのトレーニングバッチと1つのテストバッチに分割され、それぞれに10000枚の画像が含まれています。 テストバッチには、各クラスからランダムに選択された1000枚の画像が含まれています。 トレーニングバッチには残りの画像がランダムな順序で含まれていますが、一部のトレーニングバッチには、あるクラスの画像が別のクラスよりも多く含まれている場合があります。 それらの間で、トレーニングバッチには各クラスからの正確に5000枚の画像が含まれています。 データセット内のクラスと、それぞれからの10個のランダム画像は次のとおりです。
![alt](https://nttuan8.com/wp-content/uploads/2020/03/cifar10.png)
* 画像には、飛行機、自動車（トラックやピックアップトラックは除く）、鳥、猫、鹿、犬、カエル、馬、船、トラック（ピックアップトラックは除く）の10の相互に排他的なクラスのいずれかがラベル付けされています。 
3. モデルの定義
* CNNにはいろんなタイプのものがありますが、比較的簡単な構造で性能が高いものとして、VGG16と呼ばれているCNNが有名です。VGG16は畳み込み層13層とFC層3層からならCNNで、図のような構成になっています。
![alt](https://neurohive.io/wp-content/uploads/2018/11/vgg16-1-e1542731207177.png)
* 最初は224x224のRGB3枚の画像データが入力として用いられています。まず、畳み込み層+ReLUが2層あり、224x224x64のデータに変換されます。3色の特徴が64次元の特徴に変換されていることに注意してください。 
* 続いて、最大プーリングを用いて、画像サイズを縦横それぞれ1/2にします(112x112x64)。続いて、畳み込み層+ReLUを2層通して112x112x128のデータに変換しています。その後、同様に最大プーリングで56x56x128に変換した後、畳み込み層3層で56x56x256のデータに変換します。続いて、同様に28x28x512のデータに変換し、また同様に14x14x512のデータに変換しています。この後、最大プーリングを適用して、7x7x512に変換しています。つまり、画像全体をこの時点で7x7の領域に分割して、それぞれの領域に512次元のベクトルが計算されている、ということになります。そのあと、2層のFC層+ReLuを用いて、1x1x4096のベクトルに変換し、1層のFCを用いてクラス分類(1000クラスのクラス分類)のための1x1x1000次元のベクトルに変換したあと、ソフトマックスを適用しています。各層のデータサイズをわかりやすく並べると次のようになります。 
```
    Conv→BatchNorm2d→ReLU(→Pooling)が典型的な要素。
    出⼒層に近くなると FC→ReLU。
    出⼒層はFC→Softmax。
    モデルを初期化した後、追加します
    →3x3カーネルと同じパディングの64チャネルの2xコンボリューションレイヤー
    →2x2プールサイズとストライド2x2の1xmaxpoolレイヤー
    →3x3カーネルと同じパディングの128チャネルの2xコンボリューションレイヤー
    →2x2プールサイズとストライド2x2の1xmaxpoolレイヤー
    →3x3カーネルと同じパディングの256チャネルの3xコンボリューションレイヤー
    →2x2プールサイズとストライド2x2の1xmaxpoolレイヤー
    →3x3カーネルと同じパディングの512チャネルの3xコンボリューションレイヤー
    →2x2プールサイズとストライド2x2の1xmaxpoolレイヤー
    →3x3カーネルと同じパディングの512チャネルの3xコンボリューションレイヤー
    →2x2プールサイズとストライド2x2の1xmaxpoolレイヤー
 ```
* BatchNorm2dは、畳み込みニューラルネットワークの畳み込み層の後に常に追加されます。データの正規化。これにより、データが大きくなりすぎてReluの前のネットワークパフォーマンスが不安定になるのを防ぎ、畳み込みネットワークでよく使用されます（ 消失または爆発）。また、すべての負の値が次のレイヤーに渡されないように、各レイヤーにreluアクティベーションを追加します。
* forwardメソッドでは、入力xを受け取って、block1_outputを適用した後、block2_outputをかけて、その後、block3_outputを適用し、またblock4_outputをかけています。最後は、block5_outputを適用し、x = self.avgpool(x)、そのまま出力xとします。
4. 実行結果
* GPUで実行すると、約15分ぐらいで計算できます。学習率をLR=0.0001と10 epoch、GPUを使って約10分で計算でき、Accuracyは0.8097でした。 
5. 結論
*  開発の方向性：より近代的なネットワーク構造の使用
* ResNet 18、ResNet50、MobileNetV2、DLA、DenseNet 121 ....
## IMDB 
1. 問題の説明
* レビューが入力となって、その評価値(positive/negative)を出力するタスクとなります。
* ![alt](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSsCXMIfKCRBDjNZblWRJoyFGf-rQhfWWEY0w&usqp=CAU)
2. データセットの簡単な説明
* ここでは、具体的にIMDb (Internet Movie Databases)という映画やドラマのレビューを集めたデータベースを用いて、感情分析 (sentiment analysis)の学習と評価をやってみましょう。IMDbは、レビューとその評価値(positive/negative)が集められたデータベースです。訓練データは25,000件、テストデータは25,000件から成ります。 
3. データ前処理
```
  講義で提示された教師としてデータが前処理されたため、グループは再提示しませんでした。 変化する部分はモデルです。
  自然言語処理の大変なところの一つは前処理(preprocessing)です。 
  テキストをLSTM+DropOutに入力するためにこのようなステップが必要です。
  1.テキスト→トークン列 
  2. トークン列の長さ順にデータを並べ替える 
  3. 語彙リストの作成  
  4. 未知語処理 
  5. ミニバッチの作成 。 
  6. トークンを語彙IDに変換 

```
4. モデルの定義
![alt](https://upload.wikimedia.org/wikipedia/commons/thumb/6/63/Long_Short-Term_Memory.svg/1594px-Long_Short-Term_Memory.svg.png)
* 単語埋め込みにはPyTorchが用意しているnn.Embeddingというクラスがあるので、これを用います。埋め込みの次元数を300次元に設定しますpadding_idxによって、パディング用のIDを指定できます。Padding_idx=vocabidx[‘<pad>’]とすることで、<pad>に対して0ベクトルが返ってくるようになります。 
* LSTMのライブラリがありますので、これを用いましょう。LSTM、畳み込み層300次元、中間層516次元、dropout率=0.5のLSTMはtorch.nn.LSTM(300, 516, 2, dropout=0.5)で作ることができます。dropoutを指定するとLSTMの出力にdropoutがかかります。 
* Dropoutもライブラリがあるので利用しましょう。Dropout率=0.5のDropout層はtorch.nn.Dropout(0.5)で作ることができます。LSTMの出力にはDropoutがかかるようになっているので、畳み込み層の後にDropout層をかけるようにしましょう 。
* LSTMにDropoutを組み合わせることがよく行われています。Dropoutは、学習時に中間層のノードをランダムに消去して学習する手法のことです。学習時、データが流れるたびに隠れ層のノードをある割合でランダムに選択し消去して学習します。テスト時には、角層の出力に対して、訓練時に消去した割合を乗算した値を出力します。
* forwardで順伝搬の計算が行われます。emb(x)を実行すると、入力x(ミニバッチ内の全トークン列)をまとめて埋め込みます。従って、eはテキスト長✕バッチサイズ✕300のテンソルとなります。そのあと、LSTMの中間状態を初期化しておきます。
*  outputには、すべてのタイムステップの出力状態が含まれます。分類のために、ほとんどの場合、最後の状態が必要です。output= [x、batch size、hid dim * num方向]
(hidden_state, cell_state)=[num_layers, batch_size, hidden_size]
* 「hidden」を使用すると、後でLSTMに引数として渡すことで、シーケンスを続行してバックプロパゲーションを行うことができます。追加の2次元を追加します。hidden = [n layers * num directions, batch size, hid dim]。hidden [-2、：、：]はフォワードRNNの最後です。hidden [-1、：、：]は後方RNNの最後です。最後に、 a = self.l2(hidden)を計算してこれを出⼒とします。
5. 実行結果
* GPUで実行すると、約17分ぐらいで計算できます。学習率をLR=0.0001、GPUを使って約16分で計算でき、Accuracyは87%でした。 
6. 結論
*  実行結果はうまく動いていればだいたい87%ぐらいの精度になると思います。低いと思いますが、より性能の高いLSTMやアテンションの技術など用いると、90～95%以上の精度になります。
## IWSLT15を用いた機械翻訳  
1. 問題の説明
```
  * 入力は英語のテキストです
  * 出力はベトナム語のテキストです
  
```
2. データセットの簡単な説明
* IWSLT2015のShared Taskで用いられた機械翻訳タスクのデータ 
* IWSLTはInternational Workshop on Spoken Langauge Translationの略 
* データセットとしてはWMTやWATと並んで有名 
* ここでは、英語(en)-ベトナム語(vi)の対訳データを用いる 
* 訓練データ133,317文対、開発データ1,553文対、テストデータ 1,268文対 
* ここでは、具体的にIWSLT15という対訳データを用いて、機械翻訳を行ってみます。IWSLT2015のShared Taskで用いられた機械翻訳タスクのデータです。IWLSTはInternational Workshop on Spoken Langauge Translationの略です。データセットとしては、WMTやWATと並んで有名で機械翻訳のベンチマークによく用いられています。このデータセットの中に、英語(en)‐ベトナム語(vi)の対訳データがあるのでこれを用いて機械翻訳のシステムを作成、評価します。IWSLT15(en‐vi)の対訳データは、訓練データ133,317文対、開発データ1,553文対、テストデータ1,268文対から成ります。IMDbは、レビューとその評価値(positive/negative)が集められたデータベースです。訓練データは25,000件、テストデータは25,000件から成ります。 
3. データ前処理
```
  講義で提示された教師としてデータが前処理されたため、グループは再提示しませんでした。 変化する部分はモデルです。
  1番目のトークン列の 変換については、IWSLT15のデータに対して適用済みのものが配布されているので、 
  不要となります。 
  1. テキスト→トークン列(IWSLTのデータはトークナイズ済み) 
  2. 語彙リストの作成 
  3. 未知語処理 
  6. トークンを語彙IDに変換 
  最後にトークンをIDに変換します。


```
4. モデルの定義

* LSTMによってRNNに基づくエンコーダー・デコーダーモデルがかなり改善されることはわかりましたが、LSTMを使っても、エンコーダーとデコーダーの間でかなり距離がある
* ため、情報がうまく伝播されないという問題があります。

* LSTm Bidirectionalベースのエンコーダーデコーダーモデルの定義部です。
* エンコーダーは次のユニットを用います。
• encemb: エンコーダーの畳み込み層(512次元)
* 単語埋め込みにはPyTorchが用意しているnn.Embeddingというクラスがあるので、これを用います。埋め込みの次元数を512次元に設定しますpadding_idxによって、パディング用のIDを指定できます。* Padding_idx=vocabidx[‘<pad>’]とすることで、<pad>に対して0ベクトルが返ってくるようになります。
• encrnn: エンコーダーのLSTM計算ユニット(512,512,3,dropout = 0.5,  bidirectional=True)
* LSTMのライブラリがありますので、これを用いましょう。LSTM、畳み込み層512次元、中間層512次元、dropout率=0.5のLSTMはtorch.nn.LSTM(512,512,3,dropout = 0.5,  bidirectional=True)で作ることができます。
* デコーダーには次のユニットを用います。
• decemb: デコーダーの畳み込み層(512次元)
• decrnn: デコーダーのLSTM計算ユニット(512,512,3,dropout = 0.5, bidirectional=True)
• decout: デコーダーの出力(1024✕目的言語の語彙数)
* forward:LSTM bidirectionalベースのエンコーダーデコーダーモデルの学習時の順伝搬の計算です。xには、入力文のミニバッチと、出力文のミニバッチがペアになって渡されています。
x[0]で入力文のミニバッチが得られ、x[1]で出力文のミニバッチが得られます。それぞれ、x, yとします。
* そうすると、xは入力文集合を表す文長✕バッチサイズのミニバッチになり、yは出力文集合を表す文長✕バッチサイズのミニバッチとなります。
* エンコーダーの出力hとcがそのままデコーダーの中間状態hとcとして用いられます。最初はゼロで埋められた非表示状態とセル状態を保存します。
* torch.squeeze関数は、サイズ1の入力のすべての次元を削除することによってテンソルを操作するために使用されます。たとえば、形状が（Ax1xBxCx1xD）の入力テンソルを考えると、出力テンソルは次の形状（AxBxCxD）になります。
* torch.unsqueeze 関数は、目的の位置にサイズ1の新しい次元を追加することにより、出力として新しいテンソルを生成するために使用されます。この場合も、データとすべての要素は、出力として取得されたテンソルで同じままです。
5. 実行結果
* 学習率をLR=0.001、推論時の最大文長を50にして実行すると、GPUを使って約16分で計算でき、BLEUは5.11%でした。  
6. 結論
*  GPUで実行すると、約18分ぐらいで計算できます。 
*  実行結果はうまく動いていればだいたい0.9%-11%ぐらいの精度になると思います。RNNではうまく動かないということですね。より性能の高いLSTM+Dropoutでもっとまともな結果がでるようになります。 
